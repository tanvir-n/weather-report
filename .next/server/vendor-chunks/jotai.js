"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? void 0 : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((prev)=>{\n        const nextValue = store.get(atom);\n        if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n            return prev;\n        }\n        return [\n            nextValue,\n            store,\n            atom\n        ];\n    }, void 0, ()=>[\n            store.get(atom),\n            store,\n            atom\n        ]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? void 0 : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const unsub = store.sub(atom, ()=>{\n            if (typeof delay === \"number\") {\n                setTimeout(rerender, delay);\n                return;\n            }\n            rerender();\n        });\n        rerender();\n        return unsub;\n    }, [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    return isPromiseLike(value) ? use(value) : value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        if (( false ? 0 : void 0) !== \"production\" && !(\"write\" in atom)) {\n            throw new Error(\"not writable atom\");\n        }\n        return store.set(atom, ...args);\n    }, [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3VHQUMwSTtBQUM3RTtBQUU3RCxNQUFNVyw2QkFBZVYsb0RBQWFBLENBQ2hDLEtBQUs7QUFFUCxNQUFNVyxXQUFXLENBQUNDO0lBQ2hCLE1BQU1DLFFBQVFaLGlEQUFVQSxDQUFDUztJQUN6QixPQUFPLENBQUNFLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFDLEtBQUssS0FBS0EsU0FBU0wsOERBQWVBO0FBQy9FO0FBQ0EsTUFBTU0sV0FBVyxDQUFDLEVBQ2hCQyxRQUFRLEVBQ1JGLEtBQUssRUFDTjtJQUNDLE1BQU1HLFdBQVdkLDZDQUFNQTtJQUN2QixJQUFJLENBQUNXLFNBQVMsQ0FBQ0csU0FBU0MsT0FBTyxFQUFFO1FBQy9CRCxTQUFTQyxPQUFPLEdBQUdSLDBEQUFXQTtJQUNoQztJQUNBLHFCQUFPTixvREFBYUEsQ0FDbEJPLGFBQWFJLFFBQVEsRUFDckI7UUFDRUksT0FBT0wsU0FBU0csU0FBU0MsT0FBTztJQUNsQyxHQUNBRjtBQUVKO0FBRUEsTUFBTUksZ0JBQWdCLENBQUNDLElBQU0sT0FBUUEsQ0FBQUEsS0FBSyxPQUFPLEtBQUssSUFBSUEsRUFBRUMsSUFBSSxNQUFNO0FBQ3RFLE1BQU1DLE1BQU12QixzQ0FBZ0IsSUFBSyxFQUFDd0I7SUFDaEMsSUFBSUEsUUFBUUMsTUFBTSxLQUFLLFdBQVc7UUFDaEMsTUFBTUQ7SUFDUixPQUFPLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxhQUFhO1FBQ3pDLE9BQU9ELFFBQVFMLEtBQUs7SUFDdEIsT0FBTyxJQUFJSyxRQUFRQyxNQUFNLEtBQUssWUFBWTtRQUN4QyxNQUFNRCxRQUFRRSxNQUFNO0lBQ3RCLE9BQU87UUFDTEYsUUFBUUMsTUFBTSxHQUFHO1FBQ2pCRCxRQUFRRixJQUFJLENBQ1YsQ0FBQ0s7WUFDQ0gsUUFBUUMsTUFBTSxHQUFHO1lBQ2pCRCxRQUFRTCxLQUFLLEdBQUdRO1FBQ2xCLEdBQ0EsQ0FBQ0M7WUFDQ0osUUFBUUMsTUFBTSxHQUFHO1lBQ2pCRCxRQUFRRSxNQUFNLEdBQUdFO1FBQ25CO1FBRUYsTUFBTUo7SUFDUjtBQUNGO0FBQ0EsU0FBU0ssYUFBYUMsSUFBSSxFQUFFakIsT0FBTztJQUNqQyxNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNLENBQUMsQ0FBQ2tCLGtCQUFrQkMsa0JBQWtCQyxnQkFBZ0IsRUFBRUMsU0FBUyxHQUFHN0IsaURBQVVBLENBQ2xGLENBQUM4QjtRQUNDLE1BQU1DLFlBQVl0QixNQUFNdUIsR0FBRyxDQUFDUDtRQUM1QixJQUFJUSxPQUFPQyxFQUFFLENBQUNKLElBQUksQ0FBQyxFQUFFLEVBQUVDLGNBQWNELElBQUksQ0FBQyxFQUFFLEtBQUtyQixTQUFTcUIsSUFBSSxDQUFDLEVBQUUsS0FBS0wsTUFBTTtZQUMxRSxPQUFPSztRQUNUO1FBQ0EsT0FBTztZQUFDQztZQUFXdEI7WUFBT2dCO1NBQUs7SUFDakMsR0FDQSxLQUFLLEdBQ0wsSUFBTTtZQUFDaEIsTUFBTXVCLEdBQUcsQ0FBQ1A7WUFBT2hCO1lBQU9nQjtTQUFLO0lBRXRDLElBQUlYLFFBQVFZO0lBQ1osSUFBSUMscUJBQXFCbEIsU0FBU21CLG9CQUFvQkgsTUFBTTtRQUMxREk7UUFDQWYsUUFBUUwsTUFBTXVCLEdBQUcsQ0FBQ1A7SUFDcEI7SUFDQSxNQUFNVSxRQUFRM0IsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUTJCLEtBQUs7SUFDdERsQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1tQyxRQUFRM0IsTUFBTTRCLEdBQUcsQ0FBQ1osTUFBTTtZQUM1QixJQUFJLE9BQU9VLFVBQVUsVUFBVTtnQkFDN0JHLFdBQVdULFVBQVVNO2dCQUNyQjtZQUNGO1lBQ0FOO1FBQ0Y7UUFDQUE7UUFDQSxPQUFPTztJQUNULEdBQUc7UUFBQzNCO1FBQU9nQjtRQUFNVTtLQUFNO0lBQ3ZCakMsb0RBQWFBLENBQUNZO0lBQ2QsT0FBT0MsY0FBY0QsU0FBU0ksSUFBSUosU0FBU0E7QUFDN0M7QUFFQSxTQUFTeUIsV0FBV2QsSUFBSSxFQUFFakIsT0FBTztJQUMvQixNQUFNQyxRQUFRRixTQUFTQztJQUN2QixNQUFNZ0MsVUFBVXJDLGtEQUFXQSxDQUN6QixDQUFDLEdBQUdzQztRQUNGLElBQUksQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZ0JBQWdCLENBQUUsWUFBV2hCLElBQUcsR0FBSTtZQUM1RixNQUFNLElBQUltQixNQUFNO1FBQ2xCO1FBQ0EsT0FBT25DLE1BQU1vQyxHQUFHLENBQUNwQixTQUFTZ0I7SUFDNUIsR0FDQTtRQUFDaEM7UUFBT2dCO0tBQUs7SUFFZixPQUFPZTtBQUNUO0FBRUEsU0FBU00sUUFBUXJCLElBQUksRUFBRWpCLE9BQU87SUFDNUIsT0FBTztRQUNMZ0IsYUFBYUMsTUFBTWpCO1FBQ25CLHVFQUF1RTtRQUN2RStCLFdBQVdkLE1BQU1qQjtLQUNsQjtBQUNIO0FBRWlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VhdGhlci1hcHAvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcz9hYzMyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdEV4cG9ydHMsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlUmVmLCBjcmVhdGVFbGVtZW50LCB1c2VSZWR1Y2VyLCB1c2VFZmZlY3QsIHVzZURlYnVnVmFsdWUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFN0b3JlLCBjcmVhdGVTdG9yZSB9IGZyb20gJ2pvdGFpL3ZhbmlsbGEnO1xuXG5jb25zdCBTdG9yZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KFxuICB2b2lkIDBcbik7XG5jb25zdCB1c2VTdG9yZSA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICByZXR1cm4gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmUpIHx8IHN0b3JlIHx8IGdldERlZmF1bHRTdG9yZSgpO1xufTtcbmNvbnN0IFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIHN0b3JlXG59KSA9PiB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlUmVmKCk7XG4gIGlmICghc3RvcmUgJiYgIXN0b3JlUmVmLmN1cnJlbnQpIHtcbiAgICBzdG9yZVJlZi5jdXJyZW50ID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICBTdG9yZUNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHN0b3JlIHx8IHN0b3JlUmVmLmN1cnJlbnRcbiAgICB9LFxuICAgIGNoaWxkcmVuXG4gICk7XG59O1xuXG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpID0+IHR5cGVvZiAoeCA9PSBudWxsID8gdm9pZCAwIDogeC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgdXNlID0gUmVhY3RFeHBvcnRzLnVzZSB8fCAoKHByb21pc2UpID0+IHtcbiAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgIHRocm93IHByb21pc2U7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gIH0gZWxzZSB7XG4gICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAodikgPT4ge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgfSxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICBwcm9taXNlLnJlYXNvbiA9IGU7XG4gICAgICB9XG4gICAgKTtcbiAgICB0aHJvdyBwcm9taXNlO1xuICB9XG59KTtcbmZ1bmN0aW9uIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUob3B0aW9ucyk7XG4gIGNvbnN0IFtbdmFsdWVGcm9tUmVkdWNlciwgc3RvcmVGcm9tUmVkdWNlciwgYXRvbUZyb21SZWR1Y2VyXSwgcmVyZW5kZXJdID0gdXNlUmVkdWNlcihcbiAgICAocHJldikgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICAgICAgaWYgKE9iamVjdC5pcyhwcmV2WzBdLCBuZXh0VmFsdWUpICYmIHByZXZbMV0gPT09IHN0b3JlICYmIHByZXZbMl0gPT09IGF0b20pIHtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25leHRWYWx1ZSwgc3RvcmUsIGF0b21dO1xuICAgIH0sXG4gICAgdm9pZCAwLFxuICAgICgpID0+IFtzdG9yZS5nZXQoYXRvbSksIHN0b3JlLCBhdG9tXVxuICApO1xuICBsZXQgdmFsdWUgPSB2YWx1ZUZyb21SZWR1Y2VyO1xuICBpZiAoc3RvcmVGcm9tUmVkdWNlciAhPT0gc3RvcmUgfHwgYXRvbUZyb21SZWR1Y2VyICE9PSBhdG9tKSB7XG4gICAgcmVyZW5kZXIoKTtcbiAgICB2YWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgfVxuICBjb25zdCBkZWxheSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVsYXk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWIoYXRvbSwgKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzZXRUaW1lb3V0KHJlcmVuZGVyLCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgfSk7XG4gICAgcmVyZW5kZXIoKTtcbiAgICByZXR1cm4gdW5zdWI7XG4gIH0sIFtzdG9yZSwgYXRvbSwgZGVsYXldKTtcbiAgdXNlRGVidWdWYWx1ZSh2YWx1ZSk7XG4gIHJldHVybiBpc1Byb21pc2VMaWtlKHZhbHVlKSA/IHVzZSh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUob3B0aW9ucyk7XG4gIGNvbnN0IHNldEF0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ3cml0ZVwiIGluIGF0b20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCB3cml0YWJsZSBhdG9tXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3JlLnNldChhdG9tLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIFtzdG9yZSwgYXRvbV1cbiAgKTtcbiAgcmV0dXJuIHNldEF0b207XG59XG5cbmZ1bmN0aW9uIHVzZUF0b20oYXRvbSwgb3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSxcbiAgICAvLyBXZSBkbyB3cm9uZyB0eXBlIGFzc2VydGlvbiBoZXJlLCB3aGljaCByZXN1bHRzIGluIHRocm93aW5nIGFuIGVycm9yLlxuICAgIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucylcbiAgXTtcbn1cblxuZXhwb3J0IHsgUHJvdmlkZXIsIHVzZUF0b20sIHVzZUF0b21WYWx1ZSwgdXNlU2V0QXRvbSwgdXNlU3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdEV4cG9ydHMiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWR1Y2VyIiwidXNlRWZmZWN0IiwidXNlRGVidWdWYWx1ZSIsInVzZUNhbGxiYWNrIiwiZ2V0RGVmYXVsdFN0b3JlIiwiY3JlYXRlU3RvcmUiLCJTdG9yZUNvbnRleHQiLCJ1c2VTdG9yZSIsIm9wdGlvbnMiLCJzdG9yZSIsIlByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdG9yZVJlZiIsImN1cnJlbnQiLCJ2YWx1ZSIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsInVzZSIsInByb21pc2UiLCJzdGF0dXMiLCJyZWFzb24iLCJ2IiwiZSIsInVzZUF0b21WYWx1ZSIsImF0b20iLCJ2YWx1ZUZyb21SZWR1Y2VyIiwic3RvcmVGcm9tUmVkdWNlciIsImF0b21Gcm9tUmVkdWNlciIsInJlcmVuZGVyIiwicHJldiIsIm5leHRWYWx1ZSIsImdldCIsIk9iamVjdCIsImlzIiwiZGVsYXkiLCJ1bnN1YiIsInN1YiIsInNldFRpbWVvdXQiLCJ1c2VTZXRBdG9tIiwic2V0QXRvbSIsImFyZ3MiLCJlbnYiLCJNT0RFIiwiRXJyb3IiLCJzZXQiLCJ1c2VBdG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n    const key = `atom${++keyCount}`;\n    const config = {\n        toString: ()=>key\n    };\n    if (typeof read === \"function\") {\n        config.read = read;\n    } else {\n        config.init = read;\n        config.read = defaultRead;\n        config.write = defaultWrite;\n    }\n    if (write) {\n        config.write = write;\n    }\n    return config;\n}\nfunction defaultRead(get) {\n    return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n    return set(this, typeof arg === \"function\" ? arg(get(this)) : arg);\n}\nconst isSelfAtom = (atom, a)=>atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom)=>\"init\" in atom;\nconst isActuallyWritableAtom = (atom)=>!!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel)=>{\n    cancelPromiseMap.set(promise, cancel);\n    promise.catch(()=>{}).finally(()=>cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next)=>{\n    const cancel = cancelPromiseMap.get(promise);\n    if (cancel) {\n        cancelPromiseMap.delete(promise);\n        cancel(next);\n    }\n};\nconst resolvePromise = (promise, value)=>{\n    promise.status = \"fulfilled\";\n    promise.value = value;\n};\nconst rejectPromise = (promise, e)=>{\n    promise.status = \"rejected\";\n    promise.reason = e;\n};\nconst isPromiseLike = (x)=>typeof (x == null ? void 0 : x.then) === \"function\";\nconst isEqualAtomValue = (a, b)=>!!a && \"v\" in a && \"v\" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b)=>!!a && \"e\" in a && \"e\" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a)=>!!a && \"v\" in a && a.v instanceof Promise;\nconst isEqualPromiseAtomValue = (a, b)=>\"v\" in a && \"v\" in b && a.v.orig && a.v.orig === b.v.orig;\nconst returnAtomValue = (atomState)=>{\n    if (\"e\" in atomState) {\n        throw atomState.e;\n    }\n    return atomState.v;\n};\nconst createStore$1 = ()=>{\n    const atomStateMap = /* @__PURE__ */ new WeakMap();\n    const mountedMap = /* @__PURE__ */ new WeakMap();\n    const pendingStack = [];\n    const pendingMap = /* @__PURE__ */ new WeakMap();\n    let devListenersRev2;\n    let mountedAtoms;\n    if (( false ? 0 : void 0) !== \"production\") {\n        devListenersRev2 = /* @__PURE__ */ new Set();\n        mountedAtoms = /* @__PURE__ */ new Set();\n    }\n    const getAtomState = (atom)=>atomStateMap.get(atom);\n    const addPendingDependent = (atom, atomState)=>{\n        atomState.d.forEach((_, a)=>{\n            var _a;\n            if (!pendingMap.has(a)) {\n                const aState = getAtomState(a);\n                (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(a);\n                pendingMap.set(a, [\n                    aState,\n                    /* @__PURE__ */ new Set()\n                ]);\n                if (aState) {\n                    addPendingDependent(a, aState);\n                }\n            }\n            pendingMap.get(a)[1].add(atom);\n        });\n    };\n    const setAtomState = (atom, atomState)=>{\n        var _a;\n        if (( false ? 0 : void 0) !== \"production\") {\n            Object.freeze(atomState);\n        }\n        const prevAtomState = getAtomState(atom);\n        atomStateMap.set(atom, atomState);\n        if (!pendingMap.has(atom)) {\n            (_a = pendingStack[pendingStack.length - 1]) == null ? void 0 : _a.add(atom);\n            pendingMap.set(atom, [\n                prevAtomState,\n                /* @__PURE__ */ new Set()\n            ]);\n            addPendingDependent(atom, atomState);\n        }\n        if (hasPromiseAtomValue(prevAtomState)) {\n            const next = \"v\" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n            if (prevAtomState.v !== next) {\n                cancelPromise(prevAtomState.v, next);\n            }\n        }\n    };\n    const updateDependencies = (atom, nextAtomState, nextDependencies, keepPreviousDependencies)=>{\n        const dependencies = new Map(keepPreviousDependencies ? nextAtomState.d : null);\n        let changed = false;\n        nextDependencies.forEach((aState, a)=>{\n            if (!aState && isSelfAtom(atom, a)) {\n                aState = nextAtomState;\n            }\n            if (aState) {\n                dependencies.set(a, aState);\n                if (nextAtomState.d.get(a) !== aState) {\n                    changed = true;\n                }\n            } else if (( false ? 0 : void 0) !== \"production\") {\n                console.warn(\"[Bug] atom state not found\");\n            }\n        });\n        if (changed || nextAtomState.d.size !== dependencies.size) {\n            nextAtomState.d = dependencies;\n        }\n    };\n    const setAtomValue = (atom, value, nextDependencies, keepPreviousDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            v: value\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies, keepPreviousDependencies);\n        }\n        if (isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        if (hasPromiseAtomValue(prevAtomState) && hasPromiseAtomValue(nextAtomState) && isEqualPromiseAtomValue(prevAtomState, nextAtomState)) {\n            if (prevAtomState.d === nextAtomState.d) {\n                return prevAtomState;\n            } else {\n                nextAtomState.v = prevAtomState.v;\n            }\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const setAtomValueOrPromise = (atom, valueOrPromise, nextDependencies, abortPromise)=>{\n        if (isPromiseLike(valueOrPromise)) {\n            let continuePromise;\n            const updatePromiseDependencies = ()=>{\n                const prevAtomState = getAtomState(atom);\n                if (!hasPromiseAtomValue(prevAtomState) || prevAtomState.v !== promise) {\n                    return;\n                }\n                const nextAtomState = setAtomValue(atom, promise, nextDependencies);\n                if (mountedMap.has(atom) && prevAtomState.d !== nextAtomState.d) {\n                    mountDependencies(atom, nextAtomState, prevAtomState.d);\n                }\n            };\n            const promise = new Promise((resolve, reject)=>{\n                let settled = false;\n                valueOrPromise.then((v)=>{\n                    if (!settled) {\n                        settled = true;\n                        resolvePromise(promise, v);\n                        resolve(v);\n                        updatePromiseDependencies();\n                    }\n                }, (e)=>{\n                    if (!settled) {\n                        settled = true;\n                        rejectPromise(promise, e);\n                        reject(e);\n                        updatePromiseDependencies();\n                    }\n                });\n                continuePromise = (next)=>{\n                    if (!settled) {\n                        settled = true;\n                        next.then((v)=>resolvePromise(promise, v), (e)=>rejectPromise(promise, e));\n                        resolve(next);\n                    }\n                };\n            });\n            promise.orig = valueOrPromise;\n            promise.status = \"pending\";\n            registerCancelPromise(promise, (next)=>{\n                if (next) {\n                    continuePromise(next);\n                }\n                abortPromise == null ? void 0 : abortPromise();\n            });\n            return setAtomValue(atom, promise, nextDependencies, true);\n        }\n        return setAtomValue(atom, valueOrPromise, nextDependencies);\n    };\n    const setAtomError = (atom, error, nextDependencies)=>{\n        const prevAtomState = getAtomState(atom);\n        const nextAtomState = {\n            d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n            e: error\n        };\n        if (nextDependencies) {\n            updateDependencies(atom, nextAtomState, nextDependencies);\n        }\n        if (isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n            return prevAtomState;\n        }\n        setAtomState(atom, nextAtomState);\n        return nextAtomState;\n    };\n    const readAtomState = (atom, force)=>{\n        const atomState = getAtomState(atom);\n        if (!(force == null ? void 0 : force(atom)) && atomState) {\n            if (mountedMap.has(atom)) {\n                return atomState;\n            }\n            if (Array.from(atomState.d).every(([a, s])=>{\n                if (a === atom) {\n                    return true;\n                }\n                const aState = readAtomState(a, force);\n                return aState === s || isEqualAtomValue(aState, s);\n            })) {\n                return atomState;\n            }\n        }\n        const nextDependencies = /* @__PURE__ */ new Map();\n        let isSync = true;\n        const getter = (a)=>{\n            if (isSelfAtom(atom, a)) {\n                const aState2 = getAtomState(a);\n                if (aState2) {\n                    nextDependencies.set(a, aState2);\n                    return returnAtomValue(aState2);\n                }\n                if (hasInitialValue(a)) {\n                    nextDependencies.set(a, void 0);\n                    return a.init;\n                }\n                throw new Error(\"no atom init\");\n            }\n            const aState = readAtomState(a, force);\n            nextDependencies.set(a, aState);\n            return returnAtomValue(aState);\n        };\n        let controller;\n        let setSelf;\n        const options = {\n            get signal () {\n                if (!controller) {\n                    controller = new AbortController();\n                }\n                return controller.signal;\n            },\n            get setSelf () {\n                if (( false ? 0 : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n                    console.warn(\"setSelf function cannot be used with read-only atom\");\n                }\n                if (!setSelf && isActuallyWritableAtom(atom)) {\n                    setSelf = (...args)=>{\n                        if (( false ? 0 : void 0) !== \"production\" && isSync) {\n                            console.warn(\"setSelf function cannot be called in sync\");\n                        }\n                        if (!isSync) {\n                            return writeAtom(atom, ...args);\n                        }\n                    };\n                }\n                return setSelf;\n            }\n        };\n        try {\n            const valueOrPromise = atom.read(getter, options);\n            return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, ()=>controller == null ? void 0 : controller.abort());\n        } catch (error) {\n            return setAtomError(atom, error, nextDependencies);\n        } finally{\n            isSync = false;\n        }\n    };\n    const readAtom = (atom)=>returnAtomValue(readAtomState(atom));\n    const recomputeDependents = (atom)=>{\n        const getDependents = (a)=>{\n            var _a, _b;\n            const dependents = new Set((_a = mountedMap.get(a)) == null ? void 0 : _a.t);\n            (_b = pendingMap.get(a)) == null ? void 0 : _b[1].forEach((dependent)=>{\n                dependents.add(dependent);\n            });\n            return dependents;\n        };\n        const topsortedAtoms = new Array();\n        const markedAtoms = /* @__PURE__ */ new Set();\n        const visit = (n)=>{\n            if (markedAtoms.has(n)) {\n                return;\n            }\n            markedAtoms.add(n);\n            for (const m of getDependents(n)){\n                if (n !== m) {\n                    visit(m);\n                }\n            }\n            topsortedAtoms.push(n);\n        };\n        visit(atom);\n        const changedAtoms = /* @__PURE__ */ new Set([\n            atom\n        ]);\n        const isMarked = (a)=>markedAtoms.has(a);\n        for(let i = topsortedAtoms.length - 1; i >= 0; --i){\n            const a = topsortedAtoms[i];\n            const prevAtomState = getAtomState(a);\n            if (!prevAtomState) {\n                continue;\n            }\n            let hasChangedDeps = false;\n            for (const dep of prevAtomState.d.keys()){\n                if (dep !== a && changedAtoms.has(dep)) {\n                    hasChangedDeps = true;\n                    break;\n                }\n            }\n            if (hasChangedDeps) {\n                const nextAtomState = readAtomState(a, isMarked);\n                addPendingDependent(a, nextAtomState);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    changedAtoms.add(a);\n                }\n            }\n            markedAtoms.delete(a);\n        }\n    };\n    const writeAtomState = (atom, ...args)=>{\n        const getter = (a)=>returnAtomValue(readAtomState(a));\n        const setter = (a, ...args2)=>{\n            const isSync = pendingStack.length > 0;\n            if (!isSync) {\n                pendingStack.push(/* @__PURE__ */ new Set([\n                    a\n                ]));\n            }\n            let r;\n            if (isSelfAtom(atom, a)) {\n                if (!hasInitialValue(a)) {\n                    throw new Error(\"atom not writable\");\n                }\n                const prevAtomState = getAtomState(a);\n                const nextAtomState = setAtomValueOrPromise(a, args2[0]);\n                if (!isEqualAtomValue(prevAtomState, nextAtomState)) {\n                    recomputeDependents(a);\n                }\n            } else {\n                r = writeAtomState(a, ...args2);\n            }\n            if (!isSync) {\n                const flushed = flushPending(pendingStack.pop());\n                if (( false ? 0 : void 0) !== \"production\") {\n                    devListenersRev2.forEach((l)=>l({\n                            type: \"async-write\",\n                            flushed\n                        }));\n                }\n            }\n            return r;\n        };\n        const result = atom.write(getter, setter, ...args);\n        return result;\n    };\n    const writeAtom = (atom, ...args)=>{\n        pendingStack.push(/* @__PURE__ */ new Set([\n            atom\n        ]));\n        const result = writeAtomState(atom, ...args);\n        const flushed = flushPending(pendingStack.pop());\n        if (( false ? 0 : void 0) !== \"production\") {\n            devListenersRev2.forEach((l)=>l({\n                    type: \"write\",\n                    flushed\n                }));\n        }\n        return result;\n    };\n    const mountAtom = (atom, initialDependent, onMountQueue)=>{\n        var _a;\n        const existingMount = mountedMap.get(atom);\n        if (existingMount) {\n            if (initialDependent) {\n                existingMount.t.add(initialDependent);\n            }\n            return existingMount;\n        }\n        const queue = onMountQueue || [];\n        (_a = getAtomState(atom)) == null ? void 0 : _a.d.forEach((_, a)=>{\n            if (a !== atom) {\n                mountAtom(a, atom, queue);\n            }\n        });\n        readAtomState(atom);\n        const mounted = {\n            t: new Set(initialDependent && [\n                initialDependent\n            ]),\n            l: /* @__PURE__ */ new Set()\n        };\n        mountedMap.set(atom, mounted);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.add(atom);\n        }\n        if (isActuallyWritableAtom(atom) && atom.onMount) {\n            const { onMount } = atom;\n            queue.push(()=>{\n                const onUnmount = onMount((...args)=>writeAtom(atom, ...args));\n                if (onUnmount) {\n                    mounted.u = onUnmount;\n                }\n            });\n        }\n        if (!onMountQueue) {\n            queue.forEach((f)=>f());\n        }\n        return mounted;\n    };\n    const canUnmountAtom = (atom, mounted)=>!mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n    const tryUnmountAtom = (atom, mounted)=>{\n        if (!canUnmountAtom(atom, mounted)) {\n            return;\n        }\n        const onUnmount = mounted.u;\n        if (onUnmount) {\n            onUnmount();\n        }\n        mountedMap.delete(atom);\n        if (( false ? 0 : void 0) !== \"production\") {\n            mountedAtoms.delete(atom);\n        }\n        const atomState = getAtomState(atom);\n        if (atomState) {\n            if (hasPromiseAtomValue(atomState)) {\n                cancelPromise(atomState.v);\n            }\n            atomState.d.forEach((_, a)=>{\n                if (a !== atom) {\n                    const mountedDep = mountedMap.get(a);\n                    if (mountedDep) {\n                        mountedDep.t.delete(atom);\n                        tryUnmountAtom(a, mountedDep);\n                    }\n                }\n            });\n        } else if (( false ? 0 : void 0) !== \"production\") {\n            console.warn(\"[Bug] could not find atom state to unmount\", atom);\n        }\n    };\n    const mountDependencies = (atom, atomState, prevDependencies)=>{\n        const depSet = new Set(atomState.d.keys());\n        const maybeUnmountAtomSet = /* @__PURE__ */ new Set();\n        prevDependencies == null ? void 0 : prevDependencies.forEach((_, a)=>{\n            if (depSet.has(a)) {\n                depSet.delete(a);\n                return;\n            }\n            maybeUnmountAtomSet.add(a);\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                mounted.t.delete(atom);\n            }\n        });\n        depSet.forEach((a)=>{\n            mountAtom(a, atom);\n        });\n        maybeUnmountAtomSet.forEach((a)=>{\n            const mounted = mountedMap.get(a);\n            if (mounted) {\n                tryUnmountAtom(a, mounted);\n            }\n        });\n    };\n    const flushPending = (pendingAtoms)=>{\n        let flushed;\n        if (( false ? 0 : void 0) !== \"production\") {\n            flushed = /* @__PURE__ */ new Set();\n        }\n        const pending = [];\n        const collectPending = (pendingAtom)=>{\n            var _a;\n            if (!pendingMap.has(pendingAtom)) {\n                return;\n            }\n            const [prevAtomState, dependents] = pendingMap.get(pendingAtom);\n            pendingMap.delete(pendingAtom);\n            pending.push([\n                pendingAtom,\n                prevAtomState\n            ]);\n            dependents.forEach(collectPending);\n            (_a = getAtomState(pendingAtom)) == null ? void 0 : _a.d.forEach((_, a)=>collectPending(a));\n        };\n        pendingAtoms.forEach(collectPending);\n        pending.forEach(([atom, prevAtomState])=>{\n            const atomState = getAtomState(atom);\n            if (!atomState) {\n                if (( false ? 0 : void 0) !== \"production\") {\n                    console.warn(\"[Bug] no atom state to flush\");\n                }\n                return;\n            }\n            if (atomState !== prevAtomState) {\n                const mounted = mountedMap.get(atom);\n                if (mounted && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n                    mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n                }\n                if (mounted && !// Maybe we could `mountDependencies` in `setAtomState`?\n                (!hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n                    mounted.l.forEach((listener)=>listener());\n                    if (( false ? 0 : void 0) !== \"production\") {\n                        flushed.add(atom);\n                    }\n                }\n            }\n        });\n        if (( false ? 0 : void 0) !== \"production\") {\n            return flushed;\n        }\n    };\n    const subscribeAtom = (atom, listener)=>{\n        const mounted = mountAtom(atom);\n        const flushed = flushPending([\n            atom\n        ]);\n        const listeners = mounted.l;\n        listeners.add(listener);\n        if (( false ? 0 : void 0) !== \"production\") {\n            devListenersRev2.forEach((l)=>l({\n                    type: \"sub\",\n                    flushed\n                }));\n        }\n        return ()=>{\n            listeners.delete(listener);\n            tryUnmountAtom(atom, mounted);\n            if (( false ? 0 : void 0) !== \"production\") {\n                devListenersRev2.forEach((l)=>l({\n                        type: \"unsub\"\n                    }));\n            }\n        };\n    };\n    if (( false ? 0 : void 0) !== \"production\") {\n        return {\n            get: readAtom,\n            set: writeAtom,\n            sub: subscribeAtom,\n            // store dev methods (these are tentative and subject to change without notice)\n            dev_subscribe_store: (l)=>{\n                devListenersRev2.add(l);\n                return ()=>{\n                    devListenersRev2.delete(l);\n                };\n            },\n            dev_get_mounted_atoms: ()=>mountedAtoms.values(),\n            dev_get_atom_state: (a)=>atomStateMap.get(a),\n            dev_get_mounted: (a)=>mountedMap.get(a),\n            dev_restore_atoms: (values)=>{\n                pendingStack.push(/* @__PURE__ */ new Set());\n                for (const [atom, valueOrPromise] of values){\n                    if (hasInitialValue(atom)) {\n                        setAtomValueOrPromise(atom, valueOrPromise);\n                        recomputeDependents(atom);\n                    }\n                }\n                const flushed = flushPending(pendingStack.pop());\n                devListenersRev2.forEach((l)=>l({\n                        type: \"restore\",\n                        flushed\n                    }));\n            }\n        };\n    }\n    return {\n        get: readAtom,\n        set: writeAtom,\n        sub: subscribeAtom\n    };\n};\nlet defaultStore;\nconst getDefaultStore$1 = ()=>{\n    if (!defaultStore) {\n        defaultStore = createStore$1();\n        if (( false ? 0 : void 0) !== \"production\") {\n            globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n            if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n                console.warn(\"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\");\n            }\n        }\n    }\n    return defaultStore;\n};\nSymbol(( false ? 0 : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\");\nconst createStore = createStore$1;\nconst getDefaultStore = getDefaultStore$1;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQUlBLFdBQVc7QUFDZixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLEtBQUs7SUFDdkIsTUFBTUMsTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFSixTQUFTLENBQUM7SUFDL0IsTUFBTUssU0FBUztRQUNiQyxVQUFVLElBQU1GO0lBQ2xCO0lBQ0EsSUFBSSxPQUFPRixTQUFTLFlBQVk7UUFDOUJHLE9BQU9ILElBQUksR0FBR0E7SUFDaEIsT0FBTztRQUNMRyxPQUFPRSxJQUFJLEdBQUdMO1FBQ2RHLE9BQU9ILElBQUksR0FBR007UUFDZEgsT0FBT0YsS0FBSyxHQUFHTTtJQUNqQjtJQUNBLElBQUlOLE9BQU87UUFDVEUsT0FBT0YsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9FO0FBQ1Q7QUFDQSxTQUFTRyxZQUFZRSxHQUFHO0lBQ3RCLE9BQU9BLElBQUksSUFBSTtBQUNqQjtBQUNBLFNBQVNELGFBQWFDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQ2pDLE9BQU9ELElBQ0wsSUFBSSxFQUNKLE9BQU9DLFFBQVEsYUFBYUEsSUFBSUYsSUFBSSxJQUFJLEtBQUtFO0FBRWpEO0FBRUEsTUFBTUMsYUFBYSxDQUFDWixNQUFNYSxJQUFNYixLQUFLYyxXQUFXLEdBQUdkLEtBQUtjLFdBQVcsQ0FBQ0QsS0FBS0EsTUFBTWI7QUFDL0UsTUFBTWUsa0JBQWtCLENBQUNmLE9BQVMsVUFBVUE7QUFDNUMsTUFBTWdCLHlCQUF5QixDQUFDaEIsT0FBUyxDQUFDLENBQUNBLEtBQUtFLEtBQUs7QUFDckQsTUFBTWUsbUJBQW1CLGFBQWEsR0FBRyxJQUFJQztBQUM3QyxNQUFNQyx3QkFBd0IsQ0FBQ0MsU0FBU0M7SUFDdENKLGlCQUFpQlAsR0FBRyxDQUFDVSxTQUFTQztJQUM5QkQsUUFBUUUsS0FBSyxDQUFDLEtBQ2QsR0FBR0MsT0FBTyxDQUFDLElBQU1O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QjtnQkFDRjtnQkFDQSxNQUFNc0ksVUFBVUMsYUFBYXBGLGFBQWFxRixHQUFHO2dCQUM3Q25GLGlCQUFpQlEsT0FBTyxDQUN0QixDQUFDNEUsSUFBTUEsRUFBRTt3QkFBRUMsTUFBTTt3QkFBV0o7b0JBQVE7WUFFeEM7UUFDRjtJQUNGO0lBQ0EsT0FBTztRQUNMN0gsS0FBS3NHO1FBQ0xyRyxLQUFLbUc7UUFDTHNELEtBQUtGO0lBQ1A7QUFDRjtBQUNBLElBQUlTO0FBQ0osTUFBTUMsb0JBQW9CO0lBQ3hCLElBQUksQ0FBQ0QsY0FBYztRQUNqQkEsZUFBZTFIO1FBQ2YsSUFBSSxDQUFDLE1BQWUsR0FBRyxDQUFvQixHQUFHLEtBQUssT0FBTyxjQUFjO1lBQ3RFNEgsV0FBV0MsdUJBQXVCLElBQUtELENBQUFBLFdBQVdDLHVCQUF1QixHQUFHSCxZQUFXO1lBQ3ZGLElBQUlFLFdBQVdDLHVCQUF1QixLQUFLSCxjQUFjO2dCQUN2RDFGLFFBQVFDLElBQUksQ0FDVjtZQUVKO1FBQ0Y7SUFDRjtJQUNBLE9BQU95RjtBQUNUO0FBRUFJLE9BQ0UsQ0FBQyxNQUFlLEdBQUcsQ0FBb0IsR0FBRyxLQUFLLE9BQU8sZUFBZSxxQkFBcUI7QUFHNUYsTUFBTUMsY0FBYy9IO0FBQ3BCLE1BQU1nSSxrQkFBa0JMO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VhdGhlci1hcHAvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzPzliNzIiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGtleUNvdW50ID0gMDtcbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgY29uc3Qga2V5ID0gYGF0b20keysra2V5Q291bnR9YDtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIHRvU3RyaW5nOiAoKSA9PiBrZXlcbiAgfTtcbiAgaWYgKHR5cGVvZiByZWFkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25maWcucmVhZCA9IHJlYWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmluaXQgPSByZWFkO1xuICAgIGNvbmZpZy5yZWFkID0gZGVmYXVsdFJlYWQ7XG4gICAgY29uZmlnLndyaXRlID0gZGVmYXVsdFdyaXRlO1xuICB9XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbmZpZy53cml0ZSA9IHdyaXRlO1xuICB9XG4gIHJldHVybiBjb25maWc7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVhZChnZXQpIHtcbiAgcmV0dXJuIGdldCh0aGlzKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRXcml0ZShnZXQsIHNldCwgYXJnKSB7XG4gIHJldHVybiBzZXQoXG4gICAgdGhpcyxcbiAgICB0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIgPyBhcmcoZ2V0KHRoaXMpKSA6IGFyZ1xuICApO1xufVxuXG5jb25zdCBpc1NlbGZBdG9tID0gKGF0b20sIGEpID0+IGF0b20udW5zdGFibGVfaXMgPyBhdG9tLnVuc3RhYmxlX2lzKGEpIDogYSA9PT0gYXRvbTtcbmNvbnN0IGhhc0luaXRpYWxWYWx1ZSA9IChhdG9tKSA9PiBcImluaXRcIiBpbiBhdG9tO1xuY29uc3QgaXNBY3R1YWxseVdyaXRhYmxlQXRvbSA9IChhdG9tKSA9PiAhIWF0b20ud3JpdGU7XG5jb25zdCBjYW5jZWxQcm9taXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWdpc3RlckNhbmNlbFByb21pc2UgPSAocHJvbWlzZSwgY2FuY2VsKSA9PiB7XG4gIGNhbmNlbFByb21pc2VNYXAuc2V0KHByb21pc2UsIGNhbmNlbCk7XG4gIHByb21pc2UuY2F0Y2goKCkgPT4ge1xuICB9KS5maW5hbGx5KCgpID0+IGNhbmNlbFByb21pc2VNYXAuZGVsZXRlKHByb21pc2UpKTtcbn07XG5jb25zdCBjYW5jZWxQcm9taXNlID0gKHByb21pc2UsIG5leHQpID0+IHtcbiAgY29uc3QgY2FuY2VsID0gY2FuY2VsUHJvbWlzZU1hcC5nZXQocHJvbWlzZSk7XG4gIGlmIChjYW5jZWwpIHtcbiAgICBjYW5jZWxQcm9taXNlTWFwLmRlbGV0ZShwcm9taXNlKTtcbiAgICBjYW5jZWwobmV4dCk7XG4gIH1cbn07XG5jb25zdCByZXNvbHZlUHJvbWlzZSA9IChwcm9taXNlLCB2YWx1ZSkgPT4ge1xuICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gIHByb21pc2UudmFsdWUgPSB2YWx1ZTtcbn07XG5jb25zdCByZWplY3RQcm9taXNlID0gKHByb21pc2UsIGUpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gIHByb21pc2UucmVhc29uID0gZTtcbn07XG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpID0+IHR5cGVvZiAoeCA9PSBudWxsID8gdm9pZCAwIDogeC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNFcXVhbEF0b21WYWx1ZSA9IChhLCBiKSA9PiAhIWEgJiYgXCJ2XCIgaW4gYSAmJiBcInZcIiBpbiBiICYmIE9iamVjdC5pcyhhLnYsIGIudik7XG5jb25zdCBpc0VxdWFsQXRvbUVycm9yID0gKGEsIGIpID0+ICEhYSAmJiBcImVcIiBpbiBhICYmIFwiZVwiIGluIGIgJiYgT2JqZWN0LmlzKGEuZSwgYi5lKTtcbmNvbnN0IGhhc1Byb21pc2VBdG9tVmFsdWUgPSAoYSkgPT4gISFhICYmIFwidlwiIGluIGEgJiYgYS52IGluc3RhbmNlb2YgUHJvbWlzZTtcbmNvbnN0IGlzRXF1YWxQcm9taXNlQXRvbVZhbHVlID0gKGEsIGIpID0+IFwidlwiIGluIGEgJiYgXCJ2XCIgaW4gYiAmJiBhLnYub3JpZyAmJiBhLnYub3JpZyA9PT0gYi52Lm9yaWc7XG5jb25zdCByZXR1cm5BdG9tVmFsdWUgPSAoYXRvbVN0YXRlKSA9PiB7XG4gIGlmIChcImVcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICB0aHJvdyBhdG9tU3RhdGUuZTtcbiAgfVxuICByZXR1cm4gYXRvbVN0YXRlLnY7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUkMSA9ICgpID0+IHtcbiAgY29uc3QgYXRvbVN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IG1vdW50ZWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgcGVuZGluZ1N0YWNrID0gW107XG4gIGNvbnN0IHBlbmRpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgbGV0IGRldkxpc3RlbmVyc1JldjI7XG4gIGxldCBtb3VudGVkQXRvbXM7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGRldkxpc3RlbmVyc1JldjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIG1vdW50ZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgY29uc3QgZ2V0QXRvbVN0YXRlID0gKGF0b20pID0+IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gIGNvbnN0IGFkZFBlbmRpbmdEZXBlbmRlbnQgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhhKSkge1xuICAgICAgICBjb25zdCBhU3RhdGUgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgIChfYSA9IHBlbmRpbmdTdGFja1twZW5kaW5nU3RhY2subGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5hZGQoYSk7XG4gICAgICAgIHBlbmRpbmdNYXAuc2V0KGEsIFthU3RhdGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldKTtcbiAgICAgICAgaWYgKGFTdGF0ZSkge1xuICAgICAgICAgIGFkZFBlbmRpbmdEZXBlbmRlbnQoYSwgYVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVuZGluZ01hcC5nZXQoYSlbMV0uYWRkKGF0b20pO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBzZXRBdG9tU3RhdGUgPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgT2JqZWN0LmZyZWV6ZShhdG9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGF0b21TdGF0ZU1hcC5zZXQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICBpZiAoIXBlbmRpbmdNYXAuaGFzKGF0b20pKSB7XG4gICAgICAoX2EgPSBwZW5kaW5nU3RhY2tbcGVuZGluZ1N0YWNrLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYWRkKGF0b20pO1xuICAgICAgcGVuZGluZ01hcC5zZXQoYXRvbSwgW3ByZXZBdG9tU3RhdGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCldKTtcbiAgICAgIGFkZFBlbmRpbmdEZXBlbmRlbnQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBcInZcIiBpbiBhdG9tU3RhdGUgPyBhdG9tU3RhdGUudiBpbnN0YW5jZW9mIFByb21pc2UgPyBhdG9tU3RhdGUudiA6IFByb21pc2UucmVzb2x2ZShhdG9tU3RhdGUudikgOiBQcm9taXNlLnJlamVjdChhdG9tU3RhdGUuZSk7XG4gICAgICBpZiAocHJldkF0b21TdGF0ZS52ICE9PSBuZXh0KSB7XG4gICAgICAgIGNhbmNlbFByb21pc2UocHJldkF0b21TdGF0ZS52LCBuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZURlcGVuZGVuY2llcyA9IChhdG9tLCBuZXh0QXRvbVN0YXRlLCBuZXh0RGVwZW5kZW5jaWVzLCBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgTWFwKFxuICAgICAga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzID8gbmV4dEF0b21TdGF0ZS5kIDogbnVsbFxuICAgICk7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBuZXh0RGVwZW5kZW5jaWVzLmZvckVhY2goKGFTdGF0ZSwgYSkgPT4ge1xuICAgICAgaWYgKCFhU3RhdGUgJiYgaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICBhU3RhdGUgPSBuZXh0QXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKGFTdGF0ZSkge1xuICAgICAgICBkZXBlbmRlbmNpZXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0QXRvbVN0YXRlLmQuZ2V0KGEpICE9PSBhU3RhdGUpIHtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBhdG9tIHN0YXRlIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZCB8fCBuZXh0QXRvbVN0YXRlLmQuc2l6ZSAhPT0gZGVwZW5kZW5jaWVzLnNpemUpIHtcbiAgICAgIG5leHRBdG9tU3RhdGUuZCA9IGRlcGVuZGVuY2llcztcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldEF0b21WYWx1ZSA9IChhdG9tLCB2YWx1ZSwgbmV4dERlcGVuZGVuY2llcywga2VlcFByZXZpb3VzRGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0ge1xuICAgICAgZDogKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHY6IHZhbHVlXG4gICAgfTtcbiAgICBpZiAobmV4dERlcGVuZGVuY2llcykge1xuICAgICAgdXBkYXRlRGVwZW5kZW5jaWVzKFxuICAgICAgICBhdG9tLFxuICAgICAgICBuZXh0QXRvbVN0YXRlLFxuICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLFxuICAgICAgICBrZWVwUHJldmlvdXNEZXBlbmRlbmNpZXNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUocHJldkF0b21TdGF0ZSkgJiYgaGFzUHJvbWlzZUF0b21WYWx1ZShuZXh0QXRvbVN0YXRlKSAmJiBpc0VxdWFsUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgaWYgKHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEF0b21TdGF0ZS52ID0gcHJldkF0b21TdGF0ZS52O1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHNldEF0b21WYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcywgYWJvcnRQcm9taXNlKSA9PiB7XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICBsZXQgY29udGludWVQcm9taXNlO1xuICAgICAgY29uc3QgdXBkYXRlUHJvbWlzZURlcGVuZGVuY2llcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgICAgaWYgKCFoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpIHx8IHByZXZBdG9tU3RhdGUudiAhPT0gcHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlKFxuICAgICAgICAgIGF0b20sXG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSAmJiBwcmV2QXRvbVN0YXRlLmQgIT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKGF0b20sIG5leHRBdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgc2V0dGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZU9yUHJvbWlzZS50aGVuKFxuICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpO1xuICAgICAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgICAgICB1cGRhdGVQcm9taXNlRGVwZW5kZW5jaWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHByb21pc2UsIGUpO1xuICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgIHVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlUHJvbWlzZSA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICAgICAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQudGhlbihcbiAgICAgICAgICAgICAgKHYpID0+IHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpLFxuICAgICAgICAgICAgICAoZSkgPT4gcmVqZWN0UHJvbWlzZShwcm9taXNlLCBlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlc29sdmUobmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlLm9yaWcgPSB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgIHByb21pc2Uuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgICByZWdpc3RlckNhbmNlbFByb21pc2UocHJvbWlzZSwgKG5leHQpID0+IHtcbiAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICBjb250aW51ZVByb21pc2UobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRQcm9taXNlID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFByb21pc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCBwcm9taXNlLCBuZXh0RGVwZW5kZW5jaWVzLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCB2YWx1ZU9yUHJvbWlzZSwgbmV4dERlcGVuZGVuY2llcyk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21FcnJvciA9IChhdG9tLCBlcnJvciwgbmV4dERlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHtcbiAgICAgIGQ6IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICBlOiBlcnJvclxuICAgIH07XG4gICAgaWYgKG5leHREZXBlbmRlbmNpZXMpIHtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBuZXh0RGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgaWYgKGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkgJiYgcHJldkF0b21TdGF0ZS5kID09PSBuZXh0QXRvbVN0YXRlLmQpIHtcbiAgICAgIHJldHVybiBwcmV2QXRvbVN0YXRlO1xuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUoYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSAoYXRvbSwgZm9yY2UpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCEoZm9yY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGZvcmNlKGF0b20pKSAmJiBhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChtb3VudGVkTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KChbYSwgc10pID0+IHtcbiAgICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEsIGZvcmNlKTtcbiAgICAgICAgcmV0dXJuIGFTdGF0ZSA9PT0gcyB8fCBpc0VxdWFsQXRvbVZhbHVlKGFTdGF0ZSwgcyk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXh0RGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgaWYgKGlzU2VsZkF0b20oYXRvbSwgYSkpIHtcbiAgICAgICAgY29uc3QgYVN0YXRlMiA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgaWYgKGFTdGF0ZTIpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUyKTtcbiAgICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCB2b2lkIDApO1xuICAgICAgICAgIHJldHVybiBhLmluaXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSBpbml0XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYVN0YXRlID0gcmVhZEF0b21TdGF0ZShhLCBmb3JjZSk7XG4gICAgICBuZXh0RGVwZW5kZW5jaWVzLnNldChhLCBhU3RhdGUpO1xuICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUpO1xuICAgIH07XG4gICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgbGV0IHNldFNlbGY7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgfSxcbiAgICAgIGdldCBzZXRTZWxmKCkge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVhZC1vbmx5IGF0b21cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXRTZWxmICYmIGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBzZXRTZWxmID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1N5bmMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGluIHN5bmNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFNlbGY7XG4gICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWVPclByb21pc2UgPSBhdG9tLnJlYWQoZ2V0dGVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzZXRBdG9tVmFsdWVPclByb21pc2UoXG4gICAgICAgIGF0b20sXG4gICAgICAgIHZhbHVlT3JQcm9taXNlLFxuICAgICAgICBuZXh0RGVwZW5kZW5jaWVzLFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmFib3J0KClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzZXRBdG9tRXJyb3IoYXRvbSwgZXJyb3IsIG5leHREZXBlbmRlbmNpZXMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tID0gKGF0b20pID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGF0b20pKTtcbiAgY29uc3QgcmVjb21wdXRlRGVwZW5kZW50cyA9IChhdG9tKSA9PiB7XG4gICAgY29uc3QgZ2V0RGVwZW5kZW50cyA9IChhKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgZGVwZW5kZW50cyA9IG5ldyBTZXQoKF9hID0gbW91bnRlZE1hcC5nZXQoYSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50KTtcbiAgICAgIChfYiA9IHBlbmRpbmdNYXAuZ2V0KGEpKSA9PSBudWxsID8gdm9pZCAwIDogX2JbMV0uZm9yRWFjaCgoZGVwZW5kZW50KSA9PiB7XG4gICAgICAgIGRlcGVuZGVudHMuYWRkKGRlcGVuZGVudCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXBlbmRlbnRzO1xuICAgIH07XG4gICAgY29uc3QgdG9wc29ydGVkQXRvbXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBtYXJrZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdmlzaXQgPSAobikgPT4ge1xuICAgICAgaWYgKG1hcmtlZEF0b21zLmhhcyhuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrZWRBdG9tcy5hZGQobik7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgZ2V0RGVwZW5kZW50cyhuKSkge1xuICAgICAgICBpZiAobiAhPT0gbSkge1xuICAgICAgICAgIHZpc2l0KG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b3Bzb3J0ZWRBdG9tcy5wdXNoKG4pO1xuICAgIH07XG4gICAgdmlzaXQoYXRvbSk7XG4gICAgY29uc3QgY2hhbmdlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2F0b21dKTtcbiAgICBjb25zdCBpc01hcmtlZCA9IChhKSA9PiBtYXJrZWRBdG9tcy5oYXMoYSk7XG4gICAgZm9yIChsZXQgaSA9IHRvcHNvcnRlZEF0b21zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBhID0gdG9wc29ydGVkQXRvbXNbaV07XG4gICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgaWYgKCFwcmV2QXRvbVN0YXRlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGhhc0NoYW5nZWREZXBzID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGRlcCBvZiBwcmV2QXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgIGlmIChkZXAgIT09IGEgJiYgY2hhbmdlZEF0b21zLmhhcyhkZXApKSB7XG4gICAgICAgICAgaGFzQ2hhbmdlZERlcHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlZERlcHMpIHtcbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSwgaXNNYXJrZWQpO1xuICAgICAgICBhZGRQZW5kaW5nRGVwZW5kZW50KGEsIG5leHRBdG9tU3RhdGUpO1xuICAgICAgICBpZiAoIWlzRXF1YWxBdG9tVmFsdWUocHJldkF0b21TdGF0ZSwgbmV4dEF0b21TdGF0ZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkQXRvbXMuYWRkKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXJrZWRBdG9tcy5kZWxldGUoYSk7XG4gICAgfVxuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGEpKTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgLi4uYXJnczIpID0+IHtcbiAgICAgIGNvbnN0IGlzU3luYyA9IHBlbmRpbmdTdGFjay5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgcGVuZGluZ1N0YWNrLnB1c2goLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2FdKSk7XG4gICAgICB9XG4gICAgICBsZXQgcjtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXRvbSBub3Qgd3JpdGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhKTtcbiAgICAgICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHNldEF0b21WYWx1ZU9yUHJvbWlzZShhLCBhcmdzMlswXSk7XG4gICAgICAgIGlmICghaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSB3cml0ZUF0b21TdGF0ZShhLCAuLi5hcmdzMik7XG4gICAgICB9XG4gICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKHBlbmRpbmdTdGFjay5wb3AoKSk7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaChcbiAgICAgICAgICAgIChsKSA9PiBsKHsgdHlwZTogXCJhc3luYy13cml0ZVwiLCBmbHVzaGVkIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBhdG9tLndyaXRlKGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIHBlbmRpbmdTdGFjay5wdXNoKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFthdG9tXSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHdyaXRlQXRvbVN0YXRlKGF0b20sIC4uLmFyZ3MpO1xuICAgIGNvbnN0IGZsdXNoZWQgPSBmbHVzaFBlbmRpbmcocGVuZGluZ1N0YWNrLnBvcCgpKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwid3JpdGVcIiwgZmx1c2hlZCB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50QXRvbSA9IChhdG9tLCBpbml0aWFsRGVwZW5kZW50LCBvbk1vdW50UXVldWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdNb3VudCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgIGlmIChleGlzdGluZ01vdW50KSB7XG4gICAgICBpZiAoaW5pdGlhbERlcGVuZGVudCkge1xuICAgICAgICBleGlzdGluZ01vdW50LnQuYWRkKGluaXRpYWxEZXBlbmRlbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nTW91bnQ7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlID0gb25Nb3VudFF1ZXVlIHx8IFtdO1xuICAgIChfYSA9IGdldEF0b21TdGF0ZShhdG9tKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgbW91bnRBdG9tKGEsIGF0b20sIHF1ZXVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWFkQXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG1vdW50ZWQgPSB7XG4gICAgICB0OiBuZXcgU2V0KGluaXRpYWxEZXBlbmRlbnQgJiYgW2luaXRpYWxEZXBlbmRlbnRdKSxcbiAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgICB9O1xuICAgIG1vdW50ZWRNYXAuc2V0KGF0b20sIG1vdW50ZWQpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgbW91bnRlZEF0b21zLmFkZChhdG9tKTtcbiAgICB9XG4gICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkgJiYgYXRvbS5vbk1vdW50KSB7XG4gICAgICBjb25zdCB7IG9uTW91bnQgfSA9IGF0b207XG4gICAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb25Vbm1vdW50ID0gb25Nb3VudCgoLi4uYXJncykgPT4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpKTtcbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG1vdW50ZWQudSA9IG9uVW5tb3VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb25Nb3VudFF1ZXVlKSB7XG4gICAgICBxdWV1ZS5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfTtcbiAgY29uc3QgY2FuVW5tb3VudEF0b20gPSAoYXRvbSwgbW91bnRlZCkgPT4gIW1vdW50ZWQubC5zaXplICYmICghbW91bnRlZC50LnNpemUgfHwgbW91bnRlZC50LnNpemUgPT09IDEgJiYgbW91bnRlZC50LmhhcyhhdG9tKSk7XG4gIGNvbnN0IHRyeVVubW91bnRBdG9tID0gKGF0b20sIG1vdW50ZWQpID0+IHtcbiAgICBpZiAoIWNhblVubW91bnRBdG9tKGF0b20sIG1vdW50ZWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uVW5tb3VudCA9IG1vdW50ZWQudTtcbiAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICBvblVubW91bnQoKTtcbiAgICB9XG4gICAgbW91bnRlZE1hcC5kZWxldGUoYXRvbSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUoYXRvbVN0YXRlKSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKGF0b21TdGF0ZS52KTtcbiAgICAgIH1cbiAgICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkRGVwID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWREZXApIHtcbiAgICAgICAgICAgIG1vdW50ZWREZXAudC5kZWxldGUoYXRvbSk7XG4gICAgICAgICAgICB0cnlVbm1vdW50QXRvbShhLCBtb3VudGVkRGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltCdWddIGNvdWxkIG5vdCBmaW5kIGF0b20gc3RhdGUgdG8gdW5tb3VudFwiLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG1vdW50RGVwZW5kZW5jaWVzID0gKGF0b20sIGF0b21TdGF0ZSwgcHJldkRlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcFNldCA9IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKTtcbiAgICBjb25zdCBtYXliZVVubW91bnRBdG9tU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBwcmV2RGVwZW5kZW5jaWVzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2RGVwZW5kZW5jaWVzLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGlmIChkZXBTZXQuaGFzKGEpKSB7XG4gICAgICAgIGRlcFNldC5kZWxldGUoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1heWJlVW5tb3VudEF0b21TZXQuYWRkKGEpO1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXBTZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgbW91bnRBdG9tKGEsIGF0b20pO1xuICAgIH0pO1xuICAgIG1heWJlVW5tb3VudEF0b21TZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgdHJ5VW5tb3VudEF0b20oYSwgbW91bnRlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGZsdXNoUGVuZGluZyA9IChwZW5kaW5nQXRvbXMpID0+IHtcbiAgICBsZXQgZmx1c2hlZDtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGZsdXNoZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgY29sbGVjdFBlbmRpbmcgPSAocGVuZGluZ0F0b20pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghcGVuZGluZ01hcC5oYXMocGVuZGluZ0F0b20pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtwcmV2QXRvbVN0YXRlLCBkZXBlbmRlbnRzXSA9IHBlbmRpbmdNYXAuZ2V0KHBlbmRpbmdBdG9tKTtcbiAgICAgIHBlbmRpbmdNYXAuZGVsZXRlKHBlbmRpbmdBdG9tKTtcbiAgICAgIHBlbmRpbmcucHVzaChbcGVuZGluZ0F0b20sIHByZXZBdG9tU3RhdGVdKTtcbiAgICAgIGRlcGVuZGVudHMuZm9yRWFjaChjb2xsZWN0UGVuZGluZyk7XG4gICAgICAoX2EgPSBnZXRBdG9tU3RhdGUocGVuZGluZ0F0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZC5mb3JFYWNoKChfLCBhKSA9PiBjb2xsZWN0UGVuZGluZyhhKSk7XG4gICAgfTtcbiAgICBwZW5kaW5nQXRvbXMuZm9yRWFjaChjb2xsZWN0UGVuZGluZyk7XG4gICAgcGVuZGluZy5mb3JFYWNoKChbYXRvbSwgcHJldkF0b21TdGF0ZV0pID0+IHtcbiAgICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgIGlmICghYXRvbVN0YXRlKSB7XG4gICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltCdWddIG5vIGF0b20gc3RhdGUgdG8gZmx1c2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGF0b21TdGF0ZSAhPT0gcHJldkF0b21TdGF0ZSkge1xuICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIGF0b21TdGF0ZS5kICE9PSAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSkge1xuICAgICAgICAgIG1vdW50RGVwZW5kZW5jaWVzKGF0b20sIGF0b21TdGF0ZSwgcHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW91bnRlZCAmJiAhLy8gVE9ETyBUaGlzIHNlZW1zIHByZXR0eSBoYWNreS4gSG9wZSB0byBmaXggaXQuXG4gICAgICAgIC8vIE1heWJlIHdlIGNvdWxkIGBtb3VudERlcGVuZGVuY2llc2AgaW4gYHNldEF0b21TdGF0ZWA/XG4gICAgICAgICghaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBhdG9tU3RhdGUpIHx8IGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSkpKSB7XG4gICAgICAgICAgbW91bnRlZC5sLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdm9pZCAwKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZsdXNoZWQuYWRkKGF0b20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmV0dXJuIGZsdXNoZWQ7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdWJzY3JpYmVBdG9tID0gKGF0b20sIGxpc3RlbmVyKSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IG1vdW50QXRvbShhdG9tKTtcbiAgICBjb25zdCBmbHVzaGVkID0gZmx1c2hQZW5kaW5nKFthdG9tXSk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbW91bnRlZC5sO1xuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgZGV2TGlzdGVuZXJzUmV2Mi5mb3JFYWNoKFxuICAgICAgICAobCkgPT4gbCh7IHR5cGU6IFwic3ViXCIsIGZsdXNoZWQgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIHRyeVVubW91bnRBdG9tKGF0b20sIG1vdW50ZWQpO1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGRldkxpc3RlbmVyc1JldjIuZm9yRWFjaCgobCkgPT4gbCh7IHR5cGU6IFwidW5zdWJcIiB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogcmVhZEF0b20sXG4gICAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICAgIHN1Yjogc3Vic2NyaWJlQXRvbSxcbiAgICAgIC8vIHN0b3JlIGRldiBtZXRob2RzICh0aGVzZSBhcmUgdGVudGF0aXZlIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZSlcbiAgICAgIGRldl9zdWJzY3JpYmVfc3RvcmU6IChsKSA9PiB7XG4gICAgICAgIGRldkxpc3RlbmVyc1JldjIuYWRkKGwpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGRldkxpc3RlbmVyc1JldjIuZGVsZXRlKGwpO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGRldl9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gbW91bnRlZEF0b21zLnZhbHVlcygpLFxuICAgICAgZGV2X2dldF9hdG9tX3N0YXRlOiAoYSkgPT4gYXRvbVN0YXRlTWFwLmdldChhKSxcbiAgICAgIGRldl9nZXRfbW91bnRlZDogKGEpID0+IG1vdW50ZWRNYXAuZ2V0KGEpLFxuICAgICAgZGV2X3Jlc3RvcmVfYXRvbXM6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgcGVuZGluZ1N0YWNrLnB1c2goLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIGZvciAoY29uc3QgW2F0b20sIHZhbHVlT3JQcm9taXNlXSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGF0b20pKSB7XG4gICAgICAgICAgICBzZXRBdG9tVmFsdWVPclByb21pc2UoYXRvbSwgdmFsdWVPclByb21pc2UpO1xuICAgICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhhdG9tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmx1c2hlZCA9IGZsdXNoUGVuZGluZyhwZW5kaW5nU3RhY2sucG9wKCkpO1xuICAgICAgICBkZXZMaXN0ZW5lcnNSZXYyLmZvckVhY2goXG4gICAgICAgICAgKGwpID0+IGwoeyB0eXBlOiBcInJlc3RvcmVcIiwgZmx1c2hlZCB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IHJlYWRBdG9tLFxuICAgIHNldDogd3JpdGVBdG9tLFxuICAgIHN1Yjogc3Vic2NyaWJlQXRvbVxuICB9O1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5jb25zdCBnZXREZWZhdWx0U3RvcmUkMSA9ICgpID0+IHtcbiAgaWYgKCFkZWZhdWx0U3RvcmUpIHtcbiAgICBkZWZhdWx0U3RvcmUgPSBjcmVhdGVTdG9yZSQxKCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHZvaWQgMCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fIHx8IChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fID0gZGVmYXVsdFN0b3JlKTtcbiAgICAgIGlmIChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fICE9PSBkZWZhdWx0U3RvcmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuU3ltYm9sKFxuICAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB2b2lkIDApICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiQ09OVElOVUVfUFJPTUlTRVwiIDogXCJcIlxuKTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSBjcmVhdGVTdG9yZSQxO1xuY29uc3QgZ2V0RGVmYXVsdFN0b3JlID0gZ2V0RGVmYXVsdFN0b3JlJDE7XG5cbmV4cG9ydCB7IGF0b20sIGNyZWF0ZVN0b3JlLCBnZXREZWZhdWx0U3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJrZXlDb3VudCIsImF0b20iLCJyZWFkIiwid3JpdGUiLCJrZXkiLCJjb25maWciLCJ0b1N0cmluZyIsImluaXQiLCJkZWZhdWx0UmVhZCIsImRlZmF1bHRXcml0ZSIsImdldCIsInNldCIsImFyZyIsImlzU2VsZkF0b20iLCJhIiwidW5zdGFibGVfaXMiLCJoYXNJbml0aWFsVmFsdWUiLCJpc0FjdHVhbGx5V3JpdGFibGVBdG9tIiwiY2FuY2VsUHJvbWlzZU1hcCIsIldlYWtNYXAiLCJyZWdpc3RlckNhbmNlbFByb21pc2UiLCJwcm9taXNlIiwiY2FuY2VsIiwiY2F0Y2giLCJmaW5hbGx5IiwiZGVsZXRlIiwiY2FuY2VsUHJvbWlzZSIsIm5leHQiLCJyZXNvbHZlUHJvbWlzZSIsInZhbHVlIiwic3RhdHVzIiwicmVqZWN0UHJvbWlzZSIsImUiLCJyZWFzb24iLCJpc1Byb21pc2VMaWtlIiwieCIsInRoZW4iLCJpc0VxdWFsQXRvbVZhbHVlIiwiYiIsIk9iamVjdCIsImlzIiwidiIsImlzRXF1YWxBdG9tRXJyb3IiLCJoYXNQcm9taXNlQXRvbVZhbHVlIiwiUHJvbWlzZSIsImlzRXF1YWxQcm9taXNlQXRvbVZhbHVlIiwib3JpZyIsInJldHVybkF0b21WYWx1ZSIsImF0b21TdGF0ZSIsImNyZWF0ZVN0b3JlJDEiLCJhdG9tU3RhdGVNYXAiLCJtb3VudGVkTWFwIiwicGVuZGluZ1N0YWNrIiwicGVuZGluZ01hcCIsImRldkxpc3RlbmVyc1JldjIiLCJtb3VudGVkQXRvbXMiLCJlbnYiLCJNT0RFIiwiU2V0IiwiZ2V0QXRvbVN0YXRlIiwiYWRkUGVuZGluZ0RlcGVuZGVudCIsImQiLCJmb3JFYWNoIiwiXyIsIl9hIiwiaGFzIiwiYVN0YXRlIiwibGVuZ3RoIiwiYWRkIiwic2V0QXRvbVN0YXRlIiwiZnJlZXplIiwicHJldkF0b21TdGF0ZSIsInJlc29sdmUiLCJyZWplY3QiLCJ1cGRhdGVEZXBlbmRlbmNpZXMiLCJuZXh0QXRvbVN0YXRlIiwibmV4dERlcGVuZGVuY2llcyIsImtlZXBQcmV2aW91c0RlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsIk1hcCIsImNoYW5nZWQiLCJjb25zb2xlIiwid2FybiIsInNpemUiLCJzZXRBdG9tVmFsdWUiLCJzZXRBdG9tVmFsdWVPclByb21pc2UiLCJ2YWx1ZU9yUHJvbWlzZSIsImFib3J0UHJvbWlzZSIsImNvbnRpbnVlUHJvbWlzZSIsInVwZGF0ZVByb21pc2VEZXBlbmRlbmNpZXMiLCJtb3VudERlcGVuZGVuY2llcyIsInNldHRsZWQiLCJzZXRBdG9tRXJyb3IiLCJlcnJvciIsInJlYWRBdG9tU3RhdGUiLCJmb3JjZSIsIkFycmF5IiwiZnJvbSIsImV2ZXJ5IiwicyIsImlzU3luYyIsImdldHRlciIsImFTdGF0ZTIiLCJFcnJvciIsImNvbnRyb2xsZXIiLCJzZXRTZWxmIiwib3B0aW9ucyIsInNpZ25hbCIsIkFib3J0Q29udHJvbGxlciIsImFyZ3MiLCJ3cml0ZUF0b20iLCJhYm9ydCIsInJlYWRBdG9tIiwicmVjb21wdXRlRGVwZW5kZW50cyIsImdldERlcGVuZGVudHMiLCJfYiIsImRlcGVuZGVudHMiLCJ0IiwiZGVwZW5kZW50IiwidG9wc29ydGVkQXRvbXMiLCJtYXJrZWRBdG9tcyIsInZpc2l0IiwibiIsIm0iLCJwdXNoIiwiY2hhbmdlZEF0b21zIiwiaXNNYXJrZWQiLCJpIiwiaGFzQ2hhbmdlZERlcHMiLCJkZXAiLCJrZXlzIiwid3JpdGVBdG9tU3RhdGUiLCJzZXR0ZXIiLCJhcmdzMiIsInIiLCJmbHVzaGVkIiwiZmx1c2hQZW5kaW5nIiwicG9wIiwibCIsInR5cGUiLCJyZXN1bHQiLCJtb3VudEF0b20iLCJpbml0aWFsRGVwZW5kZW50Iiwib25Nb3VudFF1ZXVlIiwiZXhpc3RpbmdNb3VudCIsInF1ZXVlIiwibW91bnRlZCIsIm9uTW91bnQiLCJvblVubW91bnQiLCJ1IiwiZiIsImNhblVubW91bnRBdG9tIiwidHJ5VW5tb3VudEF0b20iLCJtb3VudGVkRGVwIiwicHJldkRlcGVuZGVuY2llcyIsImRlcFNldCIsIm1heWJlVW5tb3VudEF0b21TZXQiLCJwZW5kaW5nQXRvbXMiLCJwZW5kaW5nIiwiY29sbGVjdFBlbmRpbmciLCJwZW5kaW5nQXRvbSIsImxpc3RlbmVyIiwic3Vic2NyaWJlQXRvbSIsImxpc3RlbmVycyIsInN1YiIsImRldl9zdWJzY3JpYmVfc3RvcmUiLCJkZXZfZ2V0X21vdW50ZWRfYXRvbXMiLCJ2YWx1ZXMiLCJkZXZfZ2V0X2F0b21fc3RhdGUiLCJkZXZfZ2V0X21vdW50ZWQiLCJkZXZfcmVzdG9yZV9hdG9tcyIsImRlZmF1bHRTdG9yZSIsImdldERlZmF1bHRTdG9yZSQxIiwiZ2xvYmFsVGhpcyIsIl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fIiwiU3ltYm9sIiwiY3JlYXRlU3RvcmUiLCJnZXREZWZhdWx0U3RvcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;